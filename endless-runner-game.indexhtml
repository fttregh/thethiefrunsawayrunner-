<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Street Runner - Ka√ß Polis Geliyor!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Arial Black', Arial, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            color: #fff;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
        }

        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }

        .hud-left {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .hud-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
        }

        .hud-item {
            background: rgba(0,0,0,0.6);
            padding: 8px 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        .controls-guide {
            background: rgba(0,0,0,0.7);
            padding: 12px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
            max-width: 200px;
        }

        .controls-guide div {
            margin: 5px 0;
        }

        .coin-count::before {
            content: "ü™ô ";
        }

        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 200;
        }

        #gameOver.active {
            display: block;
        }

        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff6b35;
        }

        #gameOver .stat {
            font-size: 24px;
            margin: 10px 0;
        }

        #gameOver button {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border: none;
            color: #fff;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            margin: 20px 10px 0 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        #gameOver button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }

        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 18px;
            z-index: 100;
            animation: fadeOut 5s forwards;
        }

        @keyframes fadeOut {
            0%, 80% { opacity: 1; }
            100% { opacity: 0; }
        }

        @media (max-width: 768px) {
            #hud {
                font-size: 18px;
                top: 10px;
                left: 10px;
                right: 10px;
            }
            
            .hud-item {
                padding: 5px 10px;
            }

            .controls-hint {
                font-size: 14px;
                padding: 10px 15px;
            }
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <canvas id="gameCanvas"></canvas>

    <div id="hud">
        <div class="hud-left">
            <div class="hud-item">Skor: <span id="score">0</span></div>
            <div class="hud-item">Mesafe: <span id="distance">0</span>m</div>
            <div class="hud-item coin-count"><span id="coins">0</span></div>
        </div>
        <div class="hud-right">
            <div class="hud-item">Combo: x<span id="combo">1</span></div>
        </div>
    </div>

    <div class="controls-hint">
        ‚¨ÖÔ∏è ‚û°Ô∏è ≈ûerit deƒüi≈ütir | ‚¨ÜÔ∏è Zƒ±pla | ‚¨áÔ∏è S√ºr√ºn
    </div>

    <div id="gameOver">
        <h1>üèÅ OYUN Bƒ∞TTƒ∞</h1>
        <div class="stat">Skor: <span id="finalScore">0</span></div>
        <div class="stat">Mesafe: <span id="finalDistance">0</span>m</div>
        <div class="stat">Coin: <span id="finalCoins">0</span></div>
        <button onclick="restartGame()">üîÑ Tekrar Oyna</button>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            lanes: 3,
            laneWidth: 3,
            worldSpeed: 25,
            speedIncrease: 0.5,
            maxSpeed: 45,
            policeStartDistance: 60,
            policeSpeed: 18,
            policeCatchDistance: 2,
            obstacleInterval: 1.8,
            coinValue: 10,
            jumpHeight: 4,
            jumpDuration: 0.7,
            slideDuration: 0.5,
        };

        // Game State
        let gameState = {
            playing: true,
            score: 0,
            distance: 0,
            coins: 0,
            combo: 1,
        };

        // Three.js
        let scene, camera, renderer, clock;
        let player, policeCar;
        let obstacles = [];
        let coinsArray = [];
        let groundSegments = [];
        let lastObstacleZ = 20;
        let spawnTimer = 0;
        let currentSpeed = CONFIG.worldSpeed;
        
        const playerState = {
            lane: 1,
            targetX: 0,
            jumping: false,
            sliding: false,
            jumpTime: 0,
            slideTime: 0,
        };

        const keys = {};

        // Initialize
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 50, 120);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 300);
            camera.position.set(0, 7, -10);
            camera.lookAt(0, 2, 10);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'), 
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            
            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);
            
            const neon1 = new THREE.PointLight(0xff00ff, 1.5, 40);
            neon1.position.set(-8, 4, 30);
            scene.add(neon1);
            
            const neon2 = new THREE.PointLight(0x00ffff, 1.5, 40);
            neon2.position.set(8, 4, 50);
            scene.add(neon2);
            
            clock = new THREE.Clock();
            
            createGround();
            createPlayer();
            createPoliceCar();
            createBuildings();
            
            setupControls();
            animate();
        }

        function createGround() {
            for (let i = -5; i < 15; i++) {
                const geo = new THREE.PlaneGeometry(CONFIG.lanes * CONFIG.laneWidth + 8, 50);
                const mat = new THREE.MeshStandardMaterial({ color: 0x2a2a3e });
                const ground = new THREE.Mesh(geo, mat);
                ground.rotation.x = -Math.PI / 2;
                ground.position.z = i * 50;
                ground.receiveShadow = true;
                scene.add(ground);
                groundSegments.push(ground);
                
                // Lane lines (including right edge)
                for (let j = 0; j <= CONFIG.lanes - 1; j++) {
                    const line = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 0.05, 50),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xffff00, 
                            emissive: 0xffff00, 
                            emissiveIntensity: 0.4 
                        })
                    );
                    line.position.set(-CONFIG.laneWidth + (j + 1) * CONFIG.laneWidth, 0.03, i * 50);
                    scene.add(line);
                    groundSegments.push(line);
                }
            }
        }

        function createPlayer() {
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.6, 0.6),
                new THREE.MeshStandardMaterial({ color: 0xff6b35 })
            );
            body.castShadow = true;
            
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0xffb4a2 })
            );
            head.position.y = 1.1;
            head.castShadow = true;
            
            const mask = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.15, 0.25),
                new THREE.MeshStandardMaterial({ color: 0x000000 })
            );
            mask.position.set(0, 1.1, 0.2);
            
            player = new THREE.Group();
            player.add(body);
            player.add(head);
            player.add(mask);
            player.position.set(0, 0.8, 0);
            scene.add(player);
        }

        function createPoliceCar() {
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.9, 2.8),
                new THREE.MeshStandardMaterial({ color: 0x0066cc })
            );
            body.castShadow = true;
            
            const light1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.2, 0.2),
                new THREE.MeshStandardMaterial({ 
                    color: 0xff0000, 
                    emissive: 0xff0000, 
                    emissiveIntensity: 1 
                })
            );
            light1.position.set(-0.4, 0.6, 0);
            
            const light2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.2, 0.2),
                new THREE.MeshStandardMaterial({ 
                    color: 0x0000ff, 
                    emissive: 0x0000ff, 
                    emissiveIntensity: 1 
                })
            );
            light2.position.set(0.4, 0.6, 0);
            
            policeCar = new THREE.Group();
            policeCar.add(body);
            policeCar.add(light1);
            policeCar.add(light2);
            policeCar.position.set(0, 0.45, -CONFIG.policeStartDistance);
            scene.add(policeCar);
        }

        function createBuildings() {
            for (let i = -5; i < 100; i++) {
                const h = 8 + Math.random() * 18;
                const w = 5 + Math.random() * 4;
                const d = 5 + Math.random() * 4;
                
                // Left side building
                const buildingLeft = new THREE.Mesh(
                    new THREE.BoxGeometry(w, h, d),
                    new THREE.MeshStandardMaterial({ 
                        color: Math.random() > 0.5 ? 0x3a3a5c : 0x4a4a6c 
                    })
                );
                buildingLeft.position.set(
                    -10 - Math.random() * 5,
                    h / 2,
                    i * 12 - 50
                );
                buildingLeft.castShadow = true;
                scene.add(buildingLeft);
                
                // Right side building
                const buildingRight = new THREE.Mesh(
                    new THREE.BoxGeometry(w, h, d),
                    new THREE.MeshStandardMaterial({ 
                        color: Math.random() > 0.5 ? 0x3a3a5c : 0x4a4a6c 
                    })
                );
                buildingRight.position.set(
                    10 + Math.random() * 5,
                    h / 2,
                    i * 12 - 50
                );
                buildingRight.castShadow = true;
                scene.add(buildingRight);
            }
        }

        function spawnObstacle(lane, z) {
            const types = ['trash', 'car', 'barrier'];
            const type = types[Math.floor(Math.random() * types.length)];
            const x = (lane - 1) * CONFIG.laneWidth;
            
            let obstacle;
            
            if (type === 'trash') {
                // Realistic trash bin
                const binBody = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.45, 0.5, 1.2, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3d3d3d })
                );
                binBody.position.y = 0.6;
                
                const binLid = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.45, 0.15, 8),
                    new THREE.MeshStandardMaterial({ color: 0x2a2a2a })
                );
                binLid.position.y = 1.3;
                
                const binHandle = new THREE.Mesh(
                    new THREE.TorusGeometry(0.15, 0.05, 6, 8),
                    new THREE.MeshStandardMaterial({ color: 0x555555 })
                );
                binHandle.rotation.x = Math.PI / 2;
                binHandle.position.y = 1.35;
                
                obstacle = new THREE.Group();
                obstacle.add(binBody);
                obstacle.add(binLid);
                obstacle.add(binHandle);
                obstacle.position.set(x, 0, z);
                obstacle.userData = { needsJump: true, height: 1.4 };
                
            } else if (type === 'car') {
                // Realistic car - BIGGER
                const carBody = new THREE.Mesh(
                    new THREE.BoxGeometry(2.2, 0.9, 4.0),
                    new THREE.MeshStandardMaterial({ 
                        color: [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3][Math.floor(Math.random() * 4)],
                        metalness: 0.6,
                        roughness: 0.4
                    })
                );
                carBody.position.y = 0.45;
                
                const carRoof = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 0.6, 2.2),
                    new THREE.MeshStandardMaterial({ 
                        color: carBody.material.color,
                        metalness: 0.6,
                        roughness: 0.4
                    })
                );
                carRoof.position.y = 1.05;
                
                // Wheels
                const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.25, 8);
                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                
                const wheels = [];
                for (let i = 0; i < 4; i++) {
                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(
                        i % 2 === 0 ? -1.1 : 1.1,
                        0.3,
                        i < 2 ? 1.5 : -1.5
                    );
                    wheels.push(wheel);
                }
                
                obstacle = new THREE.Group();
                obstacle.add(carBody);
                obstacle.add(carRoof);
                wheels.forEach(w => obstacle.add(w));
                obstacle.position.set(x, 0, z);
                obstacle.userData = { needsLaneChange: true, height: 1.5 };
                
            } else {
                // Realistic barrier (horizontal bar on stands)
                const leftPost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8),
                    new THREE.MeshStandardMaterial({ color: 0xcccccc })
                );
                leftPost.position.set(-1, 0.6, 0);
                
                const rightPost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8),
                    new THREE.MeshStandardMaterial({ color: 0xcccccc })
                );
                rightPost.position.set(1, 0.6, 0);
                
                const bar = new THREE.Mesh(
                    new THREE.BoxGeometry(2.2, 0.12, 0.12),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xff0000,
                        emissive: 0xff0000,
                        emissiveIntensity: 0.3
                    })
                );
                bar.position.y = 1;
                
                // Warning stripes
                const stripe = new THREE.Mesh(
                    new THREE.BoxGeometry(2.2, 0.14, 0.14),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffff00,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.2
                    })
                );
                stripe.position.y = 1;
                stripe.position.z = 0.1;
                
                obstacle = new THREE.Group();
                obstacle.add(leftPost);
                obstacle.add(rightPost);
                obstacle.add(bar);
                obstacle.add(stripe);
                obstacle.position.set(x, 0, z);
                obstacle.userData = { needsSlide: true, height: 1 };
            }
            
            obstacle.castShadow = true;
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        function spawnCoin(lane, z) {
            const coin = new THREE.Mesh(
                new THREE.CylinderGeometry(0.25, 0.25, 0.08, 12),
                new THREE.MeshStandardMaterial({ 
                    color: 0xffd700, 
                    emissive: 0xffd700, 
                    emissiveIntensity: 0.4,
                    metalness: 0.8 
                })
            );
            coin.rotation.x = Math.PI / 2;
            coin.position.set((lane - 1) * CONFIG.laneWidth, 1.3, z);
            coin.userData = { collected: false };
            scene.add(coin);
            coinsArray.push(coin);
        }

        function setupControls() {
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                
                if (e.key === 'ArrowLeft' && playerState.lane > 0) {
                    playerState.lane--;
                } else if (e.key === 'ArrowRight' && playerState.lane < 2) {
                    playerState.lane++;
                } else if (e.key === 'ArrowUp' && !playerState.jumping && !playerState.sliding) {
                    playerState.jumping = true;
                    playerState.jumpTime = 0;
                } else if (e.key === 'ArrowDown' && !playerState.sliding && !playerState.jumping) {
                    playerState.sliding = true;
                    playerState.slideTime = 0;
                }
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });

            // Touch controls
            let touchStartX = 0, touchStartY = 0;
            
            document.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });
            
            document.addEventListener('touchend', (e) => {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 30 && playerState.lane < 2) playerState.lane++;
                    else if (dx < -30 && playerState.lane > 0) playerState.lane--;
                } else {
                    if (dy < -30 && !playerState.jumping && !playerState.sliding) {
                        playerState.jumping = true;
                        playerState.jumpTime = 0;
                    } else if (dy > 30 && !playerState.sliding && !playerState.jumping) {
                        playerState.sliding = true;
                        playerState.slideTime = 0;
                    }
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function updatePlayer(delta) {
            // Lane movement - LEFT arrow = lane--, RIGHT arrow = lane++
            // lane 0 (left) = x:-3, lane 1 (center) = x:0, lane 2 (right) = x:+3
            playerState.targetX = (playerState.lane - 1) * CONFIG.laneWidth;
            const diff = playerState.targetX - player.position.x;
            if (Math.abs(diff) > 0.05) {
                player.position.x += diff * 10 * delta;
            }
            
            // Jump
            if (playerState.jumping) {
                playerState.jumpTime += delta;
                const t = playerState.jumpTime / CONFIG.jumpDuration;
                
                if (t < 1) {
                    player.position.y = 0.8 + Math.sin(t * Math.PI) * CONFIG.jumpHeight;
                } else {
                    player.position.y = 0.8;
                    playerState.jumping = false;
                }
            }
            
            // Slide
            if (playerState.sliding) {
                playerState.slideTime += delta;
                player.position.y = 0.4;
                player.scale.y = 0.4;
                
                if (playerState.slideTime >= CONFIG.slideDuration) {
                    player.position.y = 0.8;
                    player.scale.y = 1;
                    playerState.sliding = false;
                }
            } else if (!playerState.jumping) {
                player.scale.y = 1;
            }
        }

        function updateGame(delta) {
            if (!gameState.playing) return;
            
            // Speed increase every 100m - multiplier based on distance
            const speedMultiplier = 1 + Math.floor(gameState.distance / 100);
            currentSpeed = Math.min(CONFIG.worldSpeed * speedMultiplier, CONFIG.maxSpeed * 2);
            
            // Move player forward
            player.position.z += currentSpeed * delta;
            
            // Update distance and score
            gameState.distance += currentSpeed * delta;
            gameState.score += Math.floor(currentSpeed * delta * CONFIG.distancePointsMultiplier);
            
            // Spawn obstacles
            spawnTimer += delta;
            if (spawnTimer >= CONFIG.obstacleInterval) {
                spawnTimer = 0;
                const lane = Math.floor(Math.random() * CONFIG.lanes);
                const z = player.position.z + 70;
                spawnObstacle(lane, z);
                
                // Spawn coins
                for (let i = 0; i < CONFIG.lanes; i++) {
                    if (i !== lane && Math.random() > 0.6) {
                        spawnCoin(i, z);
                    }
                }
            }
            
            // Move ground backwards to create movement illusion
            groundSegments.forEach(seg => {
                if (seg.position.z < player.position.z - 100) {
                    seg.position.z += 600;
                }
            });
            
            // Move and check obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                
                // Check collision
                const dist = Math.abs(obs.position.z - player.position.z);
                const sameLane = Math.abs(obs.position.x - player.position.x) < 1;
                
                if (sameLane && dist < 1.8) {
                    const playerHeight = player.position.y;
                    const playerIsLow = playerState.sliding || playerHeight < 1.5;
                    const playerIsHigh = playerState.jumping && playerHeight > 2.5;
                    
                    // Trash bin - needs jump
                    if (obs.userData.needsJump) {
                        if (!playerIsHigh) {
                            endGame();
                        }
                    }
                    // Car - needs lane change (can't jump over)
                    else if (obs.userData.needsLaneChange) {
                        endGame();
                    }
                    // Barrier - can pass by sliding OR jumping
                    else if (obs.userData.needsSlide) {
                        if (!playerIsLow && !playerIsHigh) {
                            endGame();
                        }
                    }
                }
                
                // Remove if behind
                if (obs.position.z < player.position.z - 20) {
                    scene.remove(obs);
                    obstacles.splice(i, 1);
                }
            }
            
            // Move and check coins
            for (let i = coinsArray.length - 1; i >= 0; i--) {
                const coin = coinsArray[i];
                coin.rotation.y += delta * 3;
                
                if (!coin.userData.collected) {
                    const dist = Math.abs(coin.position.z - player.position.z);
                    const sameLane = Math.abs(coin.position.x - player.position.x) < 1;
                    
                    if (sameLane && dist < 1.5) {
                        coin.userData.collected = true;
                        gameState.coins++;
                        gameState.score += CONFIG.coinValue * gameState.combo;
                        gameState.combo = Math.min(gameState.combo + 1, 10);
                        scene.remove(coin);
                        coinsArray.splice(i, 1);
                    }
                }
                
                if (coin.position.z < player.position.z - 20) {
                    scene.remove(coin);
                    coinsArray.splice(i, 1);
                }
            }
            
            // Police car - moves forward but slower than player
            const policeSpeed = CONFIG.policeSpeed + gameState.distance * 0.002;
            policeCar.position.z += policeSpeed * delta;
            
            if (player.position.z - policeCar.position.z < CONFIG.policeCatchDistance) {
                endGame();
            }
            
            // Police lights
            const t = clock.getElapsedTime();
            policeCar.children[1].material.emissiveIntensity = Math.sin(t * 8) > 0 ? 1 : 0.2;
            policeCar.children[2].material.emissiveIntensity = Math.sin(t * 8) < 0 ? 1 : 0.2;
            
            // Update UI
            document.getElementById('score').textContent = Math.floor(gameState.score);
            document.getElementById('distance').textContent = Math.floor(gameState.distance);
            document.getElementById('coins').textContent = gameState.coins;
            document.getElementById('combo').textContent = gameState.combo;
        }

        function endGame() {
            gameState.playing = false;
            document.getElementById('finalScore').textContent = Math.floor(gameState.score);
            document.getElementById('finalDistance').textContent = Math.floor(gameState.distance);
            document.getElementById('finalCoins').textContent = gameState.coins;
            document.getElementById('gameOver').classList.add('active');
        }

        function restartGame() {
            // Reset state
            gameState = {
                playing: true,
                score: 0,
                distance: 0,
                coins: 0,
                combo: 1,
            };
            
            playerState.lane = 1;
            playerState.jumping = false;
            playerState.sliding = false;
            player.position.set(0, 0.8, 0);
            player.scale.y = 1;
            
            policeCar.position.z = -CONFIG.policeStartDistance;
            
            // Clear obstacles and coins
            obstacles.forEach(obs => scene.remove(obs));
            obstacles = [];
            coinsArray.forEach(coin => scene.remove(coin));
            coinsArray = [];
            
            spawnTimer = 0;
            currentSpeed = CONFIG.worldSpeed;
            
            document.getElementById('gameOver').classList.remove('active');
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            updatePlayer(delta);
            updateGame(delta);
            
            camera.position.set(0, 7, player.position.z - 10);
            camera.lookAt(0, 2, player.position.z + 10);
            
            renderer.render(scene, camera);
        }

        // Start game on load
        window.addEventListener('load', init);
    </script>
</body>
</html>